Note 本文档记录了android开发中偶尔要看的备忘。

android layout的一些注意事项
 1. 最常用的布局是LinearLayout,RelativeLayout和FrameLayout
2. gravity属性对于LinearLayout和RelativeLayout有效，对FrameLayout无效
3. layout_gravity属性对于FrameLayout有效，对于LinearLayout内部元素部分有效（和orientation有关，如果是vertical，则top和bottom无效，反之，则left和right无效），对于RelativeLayout内部元素无效
4. LinearLayout中的layout_weight属性，由于这个属性有点诡异，如果想正常的发挥作用，其layout_width（orientation=horizontal）或者layout_height(orientation=vertical)最好设成0dp
5. margin这个属性，不是上下左右都一定能生效的，一般来说，左上角的margin能生效，右下角的margin就未必了
6.LinearLayout中元素无法直接覆盖，把margin设成负值可以覆盖。
7.RelativeLayout和FrameLayout默认都是从左上角开始一层一层的叠上去的，如果上层不设背景或者背景透明的话，下层的东西还是可以可见并且可以点击的，即使看不见了，下层的东西也还是可以被点击到并触发其点击事件


android 使用Monkey进行压力测试。

SDK
 1:使用友盟进行apk的自动更新
 2:使用shareSDK进行社会化分享
 3:使用极光做推送
 4：使用

Android Studio开发入门-引用jar及so文件 http://www.cnblogs.com/xrwang/p/AndroidStudioImportJarAndSoLibrary.html
一、引用jar文件
    1.将jar文件复制、粘贴到app的libs目录中；
    2.右键点击jar文件，并点击弹出菜单中的“Add As Library”，将jar文件作为类库添加到项目中；
    3.选择指定的类库。
    二、引用so文件
        网上有很多引用so文件的方法，多数都很麻烦，在KYLE THIELK的博客中找到了一种简单的方法。
        1.在“src/main”目录中新建名为“jniLibs”的目录；
        2.将so文件复制、粘贴到“jniLibs”目录内。
libs
1：一款漂亮实用的Android开源日期控件timessquare
2:推荐一个Android开发懒人库 -- ButterKnife
3: Android图表引擎AChartEngine

百度出了个api store可以查询各类服务 http://apistore.baidu.com/
身份证号码查询：http://apistore.baidu.com/apiworks/servicedetail/113.html
手机号码：http://apistore.baidu.com/apiworks/servicedetail/117.html
天气查询 http://apistore.baidu.com/apiworks/servicedetail/112.html

图灵也出了个api 图灵机器人
http://www.tuling123.com/openapi/api?key=0697f52f60f49d3a607ea09cb4e94c4a&info=帮我查一下听日广州天气
http://www.tuling123.com/openapi/modules.do?name=show


 1:Fragment  transaction.replace() VS transaction.add() hide() show()
 Fragment销毁时replace和add两个方法的区别 http://m.blog.csdn.net/blog/shimiso/44677007#
 那么最合适的处理方式是这样的：
 在add的时候，加上一个tab参数transaction.add(R.id.content, IndexFragment,”Tab1″);
 然后当IndexFragment引用被回收置空的话，先通过IndexFragment＝FragmentManager.findFragmentByTag(“Tab1″);
 找到对应的引用，然后继续上面的hide,show;

 2:TextView,Button,EditText 如果要做到按下去有变化，请使用selector
 点击父布局 使子控件（TextView等）响应点击效果 （子控件中加上这个属性 duplicateParentState）。
 例如：组件RelativeLayout上有两个TextView，这两个TextView具有不同的颜色值，现在要的效果是，当RelativeLayout被点击时，整个item有高亮背景。
 同时这两个TextView要变色。就是父控件响应点击事件，子View不响应点击事件，但是颜色要随着点击而发生变化。这样就用到了属性duplicateParentState。
 android:duplicateParentState，如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）。
 注意仅仅是获取绘图状态，而没有获取事件，也就是你点一下LinearLayout时Button有被点击的效果，但是不执行点击事件。
 在TextView中设置字体颜色一般使用，android:textColor="@color/red"，但是我们在使用selector动态修改字体颜色的时候要使用android:color="@color/red"。
 代码来设置textColor 的，需要用 textView.setTextColor(getResources().getColorStateList(R.color.text_selector_color));来设置。

 3:ListView
 --ListView记得把layout_height属性设置成match_parent。若设置成"wrap_content"则会调用多次。
 --cacheColorHint="#00000000" 自定义listview的时候，不使用#00000000会出现选中一个空间黑色底色的情况.
 --当不使用android:listSelector属性，默认会显示选中的item为橙黄底色
 ---如果你的自定义ListViewItem中有Button或者Checkable的子类控件的话，那么默认focus是交给了子控件，而ListView的Item能被选中的基础是它能获取Focus，
 也就是说我们可以通过将ListView中Item中包含的所有控件的focusable属性设置为false，这样的话ListView的Item自动获得了Focus的权限，也就可以被选中了.
 或者父控件 设置android:descendantFocusability="blocksDescendants"

 VIEWPAGER和FRAGMENT的结合使用FRAGMENT里包含着LISTVIEW的常见问题
 在我们开发的过程中可能会遇到类似需求，我们需要做一个左右滑动的tab导航，这个时候有些朋友可能会想到viewpager和fragment的结合来实现这个功能；当然实现的方法不单单着一种。我们这个随笔讨论的是这种方式实现的效果、现在假如我们选中了服务这个列，服务列下有一个listview用来展示数据。然后滑动到第二个评价的fragment再到第三个商家fragment，或者是直接到最后一个fragment，然后再回来第一个fragment，我们会发现fragment刷新了一下。这里fragment重新create了，这个时候会发现listview的数据不对了。但我们并没有进行刷新操作！这个时候我们只需要重写适配器的
 　　@Override
         public void destroyItem(ViewGroup container, int position, Object object) {
             //super.destroyItem(container, position, object);
         }
 然后把super.destroyItem(container, position, object);注释掉，让fragment一直存在着。这样你再次运行会发现刚刚那个问题已经解决了、、该问题暂时描述到这里

 4:坐标
 坐标原点是左上角.
 getRowX：触摸点相对于屏幕的坐标
 getX： 触摸点相对于按钮的坐标
 getTop： 按钮左上角相对于父view（LinerLayout）的y坐标
 getLeft： 按钮左上角相对于父view（LinerLayout）的x坐标

 5：各类框架的评价
 Volley被设计用于小的网络请求，所以像上传下载大文件什么的就不适合了，虽然网上已有相应的扩展，而且原生是没有文件上传的。
 Volley还有NetImageView，ImageLoader等和加载图片相关的，不过我个人习惯了使用UniversalImageLoader
 虽然网上都说Volley速度快，易于扩展，也给出了对比数据，但总归是要自己手工扩展，也没看出特别大的优势，和Android-Async-Http相比有一点不同就是2.3后使用了官方建议的HttpUrlConnection。
 还有一点最主要的应该就是Volley的缓存方法了，根据进行请求时服务器返回的缓存控制Header对请求结果进行缓存，下次请求时判断如果没有过期就直接使用缓存加快响应速度，如果需要会再次请求服务器进行刷新，如果服务器返回了304，表示请求的资源自上次请求缓存后还没有改变，这种情况就直接用缓存不用再次刷新页面，不过这要服务器支持了。
 当对上次的请求进行缓存后，在下次请求时即使没有网络也可以请求成功，关键的是，缓存的处理对用户完全是透明的，对于一些简单的情况会省去缓存相关的一些事情

 这个解决方案在2015年还重要吗？
 Volley/Gson的解决方案比较成熟，因为这是谷歌的解决方案，同时也因为出现在安卓开发者网站上，因此在2013到2014年都非常流行。到目前为止，这仍然是一个很好的选择，它是简单有效的。不过需要考虑一下的是Volley和Gson现在不怎么更新了。
  我们可以从速度，简便性，以及可自定义程度等因素上去分析比较不同解决方案，以帮助我们决定使用哪一种。
  你可能想尝试下一些其他的选择：
  Android 网络操作II: OkHttp, Retrofit, Moshi 以及Picasso. (即将发表)
  Android 网络操作III: ION (即将发表)

  楼主 NetworkImageView 有个很不好的地方就是没有提供图片的一些处理比如圆角处理 只能自己通过ImageLoader来写 然后做圆角处理 这方面比起github 的那个imageloader还是有些不好的
  Re: guolin 2014-05-11 09:15发表 [回复] [引用] [举报]
  回复u012807459：是的，这种情况你可以不用NetworkImageView，使用ImageRequest方法来得到一个Bitmap对象，然后再进行圆角处理就可以了。universal-image-loader也只是对圆角处理进行了一层封装而已，这样的代码在网上一搜很多的。
  楼主，在使用imageLoader加载多幅图片，这个imageLoader能够复用吗？
  ImageLoader是可以复用的，你只需要创建一次，每次调用get方法的时候传不同的ImageListener进去就行了。

  volley里如果不使用NetworkImageView加载图片就会出现图片不停的闪烁，要切换好多次才才显示最终要显示的那一张，请问有什么办法可以解决这个问题吗？？？谢谢
  Re: zz_fly 2015-07-16 15:21发表 [回复]
  回复kinbos：使用的是ListView或者GridView显示图片的吧
  是会有这种现象，因为ListView或者GridView中Item是复用的，滚动列表的时候会导致同一个Item图片被设置了很多次
  Re: 嵌入式linux_走起 2015-01-01 09:56发表 [回复]
  回复kinbos： 设置个默认图片

  博主是否想过XML解析太麻烦了，每次都要写一段XML解析的代码，有没有可能用反射开发一个工具类，就像Gson一样，传入一个JavaBean实体类就可以解析出对象了？
  Re: guolin 2014-04-29 18:19发表 [回复] [引用] [举报]
  回复angerlie：说实话我曾经有想过写一个这样的开源库的，不过真正动起手来的时候你就会发现，这个任务很难完成，因为XML的数据结构比JSON要复杂很多，除了基本的结点、内容之外，还有结点属性、前缀、命名空间等等，这些都是没法映射到对象里面的，不像JSON那样简洁。
  Re: angerlie 2014-05-20 09:55发表 [回复] [引用] [举报]
  回复sinyu890807：恩，我同样遇到了这些困难。项目中为了节省带宽，改用Json了，于是没有在研究自动解析xml了。

  群主，当初刚做Android的时候拜读这系列文章，使用Volley下载图片显示在ListView里，更新界面的时候出现闪图的情况，急急忙忙加了你的群，在里面求问。但问题还是没解决，改了方案。。。。半年过去了，再次拜读，发现原因所在了-----Volley的缓存是文件缓存，没有内存缓存。
    哎，会想往事，不胜唏嘘
  Re: wyyl1 2015-06-15 22:04发表 [回复]
  回复_游离：我也遇到了相同的问题，后来在网上搜了一下，原来问题出在了sizeOf方法，之后重写了之后就好了mCache = new LruCache<String, Bitmap>(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) {// return bitmap.getRowBytes() * bitmap.getHeight(); return bitmap.getByteCount() / 1024; }
  Re: asdzheng 2015-01-23 14:30发表 [回复] [引用] [举报]
    回复_游离：我最近也被这个问题困惑着，我们用来保存图片的缓存不是用lrucache吗，而lrucache不是内存缓存么，怎么是文件缓存了呢？如有时间请回复一下，谢谢。
  Re: zg524495133 2015-01-30 14:34发表 [回复] [引用] [举报]
  回复asdzheng：默认是文件缓存哦内存缓存Lru是自己实现的

  比如一个新闻列表数据，第一次进入时候没有缓存就读取网络数据，并且放入缓存。但是第二次进入的时候会不会直接读缓存而不加载网络从而获取不到最新的数据呢？是不是进行了过期判断？ 里面有一个过期判断但是这部分没想太明白希望开导~~谢谢
  Re: 最怕认真 2015-02-02 00:39发表 [回复]
  回复zg524495133：我也想问这个问题啊。。。每次进入都要重新下载。但是有些图片就是万年不变的额。。
  Re: wikikii 2015-03-09 11:23发表 [回复]
  回复最怕认真：你可以自己写一个图片的缓存存起来，然后调用啊
  Re: lanhun7 2015-08-28 23:29发表 [回复]
  回复wikikii：第一次进入，没有缓存（getbitmap这里要自己实现如lrucache），再读取diskbasedcache,然后再读取网络。网络数据获取到后，先存到diskbasedcache，然后在存到你自己实现的lrucache，在putbitmap这个接口里面。最后再回调你自己的lisenter。
  当然过期，比如是获取图片getbitmap在这个之后所以这里就判断不了直接读的以前的。若你没自己缓存到自己的内存，那么过期了就直接申请网络的了

随着Android的发展，各路大神的贡献，我们可用的轮子越来越多。比如HTTP请求框架，有自家的Volley，Square的okhttp, async-http-lib, 还有聚合版的xUtils以及AFinal。我想你肯定用过其中一个。
当然Stay今天不是来科普的，而是来跟大家一起思考一个问题的。我们暂且不提他们在内部做了多少优化，我们就说lib的返回数据。
 在常用的http请求的返回值中，文件，JSON占绝大多数（图片有其他框架，这里不考虑）。文件下载都有专门的response，会帮你下载到制定路径，这个肯定都支持。那JSON呢？貌似都返回一个JSONObject或者JSONArray。
 我去，做好事得做全啊，返回JSONObject是个什么鬼，难道还得自己动手写解析反序列化成自己要得对象？那是最低级的程序员干的事。好在我们都不傻，还有GSON，fastJson，Jackson帮我们来完成这步转化。


 Volley的源代码存放在这里，你可以用git clone直接获取：
 git clone https://android.googlesource.com/platform/frameworks/volley
 在下载后的代码目录中适用”ant jar”命令完成编译，会生成volley.jar包，这样你就能在Eclipse或Android Studio中适用啦。